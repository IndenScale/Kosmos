# 设计文档：Git-like 本体论版本控制系统

## 1. 设计哲学

在 Kosmos 系统的核心，本体论不仅是“配置”，更是知识的“宪法”。为了支持其安全、可审计、可追溯的演进，我们摒弃了简单的 JSON 字段存储，设计并实现了一套受 Git 版本控制系统启发的、完全范式化的数据库模型。

其核心设计思想源于 Git：

- **不可变性 (Immutability):** 本体论的任何一个历史版本都是一个不可更改的永久快照。我们不“修改”历史，只“创造”新的历史。
- **血缘追溯 (Lineage):** 每个版本都清晰地知道它的“父版本”是谁，形成一条完整的、可审计的演化链，让知识的每一次脉动都有迹可循。
- **原子性变更 (Atomic Changes):** 对本体论的任何一次修改（无论多小），都会生成一个全新的、完整的版本快照，确保了系统状态的一致性。

## 2. 核心数据模型 (四大支柱)

该系统由四张核心的数据库表构成，它们的关系完美地映射了 Git 的核心概念。

### 2.1. `Ontology` (仓库 - The Repository)

- **职责:** 作为一个“仓库”的顶层管理者，每个知识空间 (`KnowledgeSpace`) 都有唯一一个与之对应的 `Ontology` 记录。
- **核心字段:**
    - `knowledge_space_id`: 关联到所属的知识空间。
    - `active_version_id`: 一个动态的“指针”，永远指向当前对用户可见的“活跃”版本。这就像 Git 中的 `HEAD` 指针。
- **Git 类比:** `git repository` 本身。

### 2.2. `OntologyVersion` (提交 - The Commit)

- **职责:** 这是系统的**核心**。每一条记录都代表本体论在某个时间点的一次**完整、独立的快照**。
- **核心字段:**
    - `parent_version_id`: 指向其父版本的 `id`，构建了完整的血缘链。
    - `commit_message`: 记录本次变更的理由（Why）。
    - `created_by_user_id`, `created_at`: 记录是谁（Who）在何时（When）进行了提交。
    - `serialized_nodes`: 一个冗余的 JSON 字段，存储了该版本下所有节点的序列化快照，用于快速加载和前端展示，避免了昂贵的递归查询。
- **Git 类比:** `git commit` 对象。

### 2.3. `OntologyNode` (数据 - The Data/Blob)

- **职责:** 存储构成本体论的**原子单元**——每一个概念节点。这张表中的记录被设计为**事实上的不可变对象**。
- **核心字段:**
    - `stable_id`: 一个在所有版本中都保持不变的稳定 ID，用于追踪一个逻辑概念（如“无线技术”）在多次修改中的演化过程。
    - `name`, `constraints`, `node_metadata`: 存储概念节点的具体内容。
    - `content_hash`: 根据节点内容计算的哈希值，用于快速识别和复用完全相同的节点，实现存储层面的去重。
- **Git 类比:** `git blob` 对象，即文件的具体内容。

### 2.4. `OntologyVersionNodeLink` (树 - The Tree)

- **职责:** 作为连接 `Version` 和 `Node` 的桥梁。它是一张清单，详细说明了**“哪个版本包含了哪些节点，以及这些节点在该版本中的层级关系是怎样的”**。
- **核心字段:**
    - `version_id`: 指向其所属的版本。
    - `node_id`: 指向其包含的节点。
    - `parent_node_id`: 定义了该节点在此版本中的父节点是谁，从而动态地构建出每个版本的树状结构。
- **Git 类比:** `git tree` 对象，定义了目录结构和文件清单。

## 3. 服务层实现 (`OntologyService`)

所有对本体论的操作都被封装在 `OntologyService` 中，它是与本体论模型交互的唯一入口。

### 3.1. 核心工作流：批量提交引擎

所有写操作（无论是粒度化修改还是批量更新）最终都由一个私有的核心引擎 `_commit_new_version_from_changes` 驱动。其工作流程如下：

1.  **创建新版本 (Commit):**
    a. 系统创建一个新的 `OntologyVersion` 记录 (v2)，并将其 `parent_version_id` 指向当前的活跃版本 (v1)。
2.  **复制链接 (Copy Links):**
    a. 为了实现写时复制（Copy-on-Write），引擎首先在**内存中**创建一个父版本 (v1) 所有链接记录的**副本**。这个副本代表了新版本 (v2) 的初始状态。
3.  **应用变更 (Apply Changes):**
    a. 引擎按照 `删除 -> 新增 -> 更新 -> 移动` 的安全顺序，遍历一个“变更指令”列表。
    b. **删除 (delete):** 从内存中的链接副本里，移除被删除节点及其所有子孙节点的链接。
    c. **新增 (add):** 创建一个新的 `OntologyNode` 记录，然后在内存中的链接副本里增加一条指向它的新链接。
    d. **更新 (update):** 创建一个**新的** `OntologyNode` 记录（继承旧节点的 `stable_id`），然后在内存中的链接副本里，将指向旧节点的链接**修改**为指向新节点。
    e. **移动 (move):** 在内存中的链接副本里，直接修改目标节点的链接，使其指向新的父节点。
4.  **持久化 (Persist):**
    a. 将内存中最终状态的链接副本全部写入数据库，并关联到新版本 (v2)。
5.  **重建快照 (Rebuild Snapshot):**
    a. 基于 v2 的新链接关系，重新计算并生成完整的树状结构，存入 `OntologyVersion.serialized_nodes` 字段。
6.  **切换指针 (Update HEAD):**
    a. 将 `Ontology.active_version_id` 更新为 v2 的 ID。所有操作在一个数据库事务中完成。

### 3.2. 接口类型

`OntologyService` 提供两类主要的写操作接口：

#### a) 粒度化修改接口

- `add_node`, `update_node`, `move_node`, `delete_node`
- **职责:** 为上层应用提供意图明确的、一次只执行一个操作的简单接口。
- **工作方式:** 每个接口都会构造一个包含单条指令的“变更列表”，然后调用核心的提交引擎。

#### b) 批量 JSON 更新接口

- `commit_version_from_json_tree`
- **职责:** 支持用户通过粘贴完整 JSON 的方式来更新本体论，提供“所见即所得”的编辑体验。
- **工作方式:**
    1.  **差异计算 (`_calculate_diff`):** 该接口首先调用一个“差异引擎”。
    2.  引擎通过 `_flatten_tree_to_map` 辅助函数将当前树和新树都“拍平”成以 `stable_id` 为键的字典。
    3.  通过对比两个字典，引擎可以高效地计算出从当前状态到目标状态所需的所有原子操作（新增、删除、更新、移动）。
    4.  **批量提交:** 差异引擎的输出是一个完整的“变更列表”，该列表被直接传递给核心的提交引擎 `_commit_new_version_from_changes` 来执行。

## 4. 设计优势

- **完整的审计与追溯能力:** 任何变更都有记录，永不丢失。
- **无锁并发:** “写”操作永远是创建新记录，天然避免了并发修改同一条记录的锁竞争问题。
- **原子性与一致性:** 每次变更都产生一个完整的、一致的新版本，杜绝了中间状态。
- **数据去重:** 通过 `content_hash` 复用 `OntologyNode`，节约了存储空间。
- **强大的扩展性:** 为未来实现分支（Branching）、合并（Merging）等高级协作功能奠定了坚实的基础。